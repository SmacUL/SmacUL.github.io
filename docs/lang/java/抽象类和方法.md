# 抽象类与抽象方法

 

抽象类：包含抽象方法的类（abstract 关键字）；

如果子类继承抽象类，且子类没有给出父类中所有抽象方法的实现，子类也会被算作抽象类；

::: tip 
抽象类无法被创建，只能作为基类存在；
:::
 

 

# 接口

 

接口（interface 关键字）表达了类与类之间的关系（协议）；

 

## 性质

接口可以视作只有抽象方法的抽象类；

接口中的属性默认为 public static final ；

接口中的方法默认为 public；

::: tip 
在过去接口可以被视作一种用来创建常量组的工具，SE5 后，建议使用 enum
:::

 

## 通过继承来扩展接口

 

Java 允许接口使用 extends 关键字继承；

::: tip 
在打算组合的不同接口中使用相同名称的方法通常会带来糟糕的可读性，不建议使用
:::
 

## 嵌套接口

 

## 工厂模式

工厂父类（接口）负责定义产品对象的公共接口，而子类工厂则负责创建具体的产品对象。

工厂方法是为了把产品的实例化操作延迟到子类工厂中完成，通过工厂子类来决定究竟应该实例化哪一个产品具体对象。

 

工厂方法在刚开始看起来应该会感觉没什么卵用，它的一大功能是代替对象实例化语句（new），部分对象在实例化的过程中可能需要非常复杂的操作，如果将这些使用代码都放入构造器中，一是增加了风险（构造器 多态），二是增加了实例化和使用的耦合度；

在数据库的初始化部分，工厂方法用的会多一些。

 

工厂方法降低了代码之间的耦合度，就像代码二中所示，如果没有 Factory 类的存在，同时又修改了 Game 类中的方法，或者替换了 Game 类，在引用了 Game 类的代码中就需要一处处地修改。Factory 的存在就允许只在 Factory 的类内部修改与 Game 相关的内容即可。

 

::: tip 
留意 「工厂模式」 「简单工厂模式」 「抽象工厂模式」 按需使用；
:::
 

「见代码二」

 

# Java 的多重继承

 

Thinking in Java 中给出的复杂例子：

一个类可以同时继承父类，并且同时实现多个接口；

如果父类 implement 和子类 implement 了一样的接口，那么子类可以不实现此接口中的方法，或重写此接口中的方法；

::: tip 
如果 implement 了接口，就需要实现接口中的所有方法，
:::

除非当前定义的是抽象类；

「见代码一」