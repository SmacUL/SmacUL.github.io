# 基本

 

内部类：将一个类的定义放在另一个类、方法的定义内部；

通常，在外部类会有一个方法（像工厂方法那样）返回一个指向内部类对象的引用；

内部类的标识符：<外围类的名字>$<内部类的名字>

 


## 内部类如何链接至外部类

 

内部类拥有其外部类所有元素的访问权限；

构建内部类对象时，编译器会自动添加一个指向外部类对象的引用；

如果内部类被 static 修饰，则它与外部类的联系将被打断；

 


## .this 和 .new 关键字

 

两个关键字的基本使用参考「代码一」

 

## .this 内部类获得外部类对象的引用

<外部类>.this : 生成对外部类对象的引用；

 

## .new 直接创建内部类的对象

<外部类>.new : 需要使用外部类对象来创建内部类对象；

内部类完整类名： <外部类名>.<内部类名> ；

 

 

# 内部类的访问权限设置

 

 

见「代码二」

## 代码一

 

``` Java
class Test {
  private int i;
  class TestInner {
    void func() {
      // 在内部类中获得外部类的引用, 同时给外部类的 i 赋值
      Test.this.func(4);
      // 在内部类中使用外部类域中的 i
      System.out.println("testInner " + i);
    }
  }
  void func(int i) {
    this.i = i;
    System.out.println("test " + i);
  }
}
 
public class ObjectTest {
  public static void main(String[] args) {
    // 直接创建内部类
    Test t = new Test();
    Test.TestInner ti = t.new TestInner();
    ti.func();
  }
}
```

 代码二

 

``` Java
class Test {
    private int i;
    
    Test(int i) {
        this.i = i;
    }
 
    void func(int j) {
        // 对于 Inner 来说，它属于 func 方法，而不属于 Test 类
        class Inner {
            void funcB() {
                // 位于 Inner 类内部的 funcB 方法，
                // 可以获得与 func 方法一样的东西
                System.out.println(i);
                System.out.println(j);
            }
        }
    }
 
    void getInner() {
        // 对于 Test 类来说，Inner 已经不再是自己的成员，无法直接获取
        // 以下就是一个非法操作
        return new Inner();
    }
 
}
```

# 代码三

``` Java
/**
 * Callee 要求其调用需要实现的接口
 */
interface CallBackInterface {
    void callBack(int id);
}
 
/**
 * 被调用者，
 * 需要使用它，就要实现它定义的 CallBackInterface 接口，
 * 如果 Callee 才能知晓 handelMethod 主体逻辑完成后的操作；
 */
class Callee {
    void handelMethod(CallBackInterface cbi, int id) {
        System.out.println("2. 任务完成，准备通知 Caller" + id);
        cbi.callBack(id);
    }
}
 
class CallerA implements CallBackInterface {
    @Override
    public void callBack(int id) {
        System.out.println("3. 干得好，from Caller" + id);
    }
 
    void callCallee() {
        System.out.println("1. 呼叫 Callee 准备干活");
        Callee callee = new Callee();
        callee.handelMethod(this, 1);
    }
}
 
class CallerB {
    /**
    * RealCallerB 将实现回调函数，且权限设置为 private
    * 如此，在使用中，就不需要将整个 Caller 对象都交给 Callee ，
    */
    private class RealCallerB implements CallBackInterface {
        @Override
        public void callBack(int id) {
        System.out.println("3. 干得好，from Caller" + id);
        }
    }
    /**
    * RealCallerB 的 get 方法
    * @return
    */
    CallBackInterface getRealCallerB() {
        return new RealCallerB();
    }
    
    void callCallee() {
        System.out.println("1. 呼叫 Callee 准备干活");
        new Callee().handelMethod(getRealCallerB(), 2);
    }
 
}
 
class CallerC {
    void callCallee() {
        System.out.println("1. 呼叫 Callee 准备干活");
        new Callee().handelMethod(new CallBackInterface() {
        @Override
        public void callBack(int id) {
            System.out.println("3. 干得好，from Caller" + id);
        }
        }, 3);
    }
}
 
public class DefaultClass {
 
    public static void main(String[] args) {
        System.out.println("传统的回调");
        CallerA callerA = new CallerA();
        callerA.callCallee();
    
        System.out.println("\n内部类中的回调");
        CallerB callerB = new CallerB();
        callerB.callCallee();
    
        System.out.println("\n匿名类中的回调");
        CallerC callerC = new CallerC();
        callerC.callCallee();
    }
}
```

 