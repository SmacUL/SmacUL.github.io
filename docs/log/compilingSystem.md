# Compiling System

## win10安装使用gcc

这个操作一开始是为了方便在windows能中利用vs code的code runner插件能够直接编译运行C语言，因为编译系统的学习也需要gcc的支持，又不愿频繁地切换系统，所以拉过来用一下。

- 下载并安装mingw64  

    这是一个为方便那些想在windows环境下体验gcc的人而移植过来的一套系统。  
    可能需要翻个墙，或者在小店里面下载

- 具体的看这个

    [mingw64](https://www.cnblogs.com/x_wukong/p/4833578.html)

- 安装结束之后，打开cmd或者terminal输入

    ``` shell
    gcc --version
    ```
    如果有类似提示，则安装成功
    ``` shell
    gcc.exe (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0
    Copyright (C) 2018 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    ```

## 开始

文中的内容主要用win10的powershell来完成（代替terminal，这是个不错的选择）  
此外下方内容出现的一些指令可以使用

``` shell
gcc --help
```

来查询。

## gcc编译过程

- 预编译

    简单理解为文件替换，主要处理include的文件和定义的宏。实际上编译器所实现的操作和预编译是类似的，一个完整的编译器是需要预编译器的。将c文件（源文件）转为i文件（预编译文件）。
    ``` shell
    gcc -E <file.c> -o <file.i>
    ```
    -E: Preprocess only; do not compile, assemble or link.  
    -o: Place the output into \<file>.

- 编译  

    编译操作之后产生的是汇编代码，汇编代码的格式语法随系统而不同 。将i文件转为s文件（汇编文件）。
    ``` shell
    gcc -S <file.i> -o <file.s>
    ```
    -S: Compile only; do not assemble or link.

- 汇编  

    将汇编代码（源文件）变成目标文件。将s文件转为o文件（目标文件）
    ``` shell
    gcc -c <file.s> -o <file.o>
    ```
    -c: Compile and assemble, but do not link

    目标文件可以用gcc的自带工具objdump打开
    ``` shell
    objdump.exe -sd <file.o>
    ```

- 链接  

    这一步将生成可运行的exe文件
    ``` shell
    gcc <file.o> -o <file> -static
    ```
    -static 使用静态链接的方式（gcc默认是动态链接），动态链接的方式比较复杂，使用静态链接降低难度。

    同样exe文件也是可以用objdump工具打开查看的。

- 一次性的操作

    ``` shell
    gcc <file.c> -o <file>
    ```
    这里最终生成的是一个可执行目标文件，利用
    ``` shell
    ./file
    ```
    调用一个加载器函数，将file中的代码和数据写入到内存中，再将控制转移到这个程序的开头。

## 目标文件

1. 可重定位目标文件

    在编译时可以和其他的重定位目标文件合并起来，创建出一个可执行目标文件。

1. 可执行目标文件

    可以被直接加载到内存中执行的文件。

1. 共享目标文件

    在加载或者运行时被动态地加载入内存中并链接。

## 编译系统设计

这里的编译系统分成三个部分，编译、汇编、链接。编译和汇编是为了获得可重定位目标文件，链接是为了获得可执行目标文件，三者共同的目的就是在人和电脑之间构建一个沟通的桥梁。

1. 编译程序设计

    编译程序设计需要经过以下几个步骤：

        源文件（*.c）->词法分析->语法分析->语义分析->代码生成->汇编文件（*.s）
    编译程序的主要任务是将源程序代码转化为汇编代码。

    - 词法分析

        利用词法分析器将源代码拆分成一个个**词法记号**，例如

            a = b + c;
        这句话中包含了6个词法记号。在源代码中有各类不同的词法记号：标识符、常量等，语法分析器中内置有相应的不同类型的**有限自动机**来识别这些字符。有限自动机是一种正常情况下会自动读取识别词法记号，而当遇到异常字符就会停止的机制（如果在非结束状态读入了异常的字符，就意味着词法错误），这里的正常结束是指碰到那些合法的但是不是当前自动机需要识别的字符。

    - 语法分析

        语法分析的任务是将词法分析后的词法记号序列变成一种树壮的数据结构，**抽象语法树**。所有的词法记号都将出现在数的叶子节点上，称之为**终结符**；非叶子结点是一串词法记号的抽象，相应的，就被称为非终结符。

                - 语句
                    - a
                    - =
                    - 表达式
                        - b
                        - +
                        - c
                    - ;

            a = b + c;进行语法分析后得到的抽象语法树，这里的语句、表达式就可视为非终结符。

        在实际的语法分析器中，并不需要显示地构造出语法树，需要的信息能在程序中正确保留变化即可。

    - 语义分析

        现在计算机程序语言采用上下文无关的**文法**，即程序代码在文法层次上是没有关联的，而所谓文法就是程序的语言的语法规则。在语义分析中，只考虑了程序语言形式的合法性，而语言上下文之间联系的合法性没有被分析过，所以再生成汇编代码前还需要语义分析。编译器的语义分析大概在处理以下的一些问题：

            - 变量以及函数使用前是否定义
            - 计算及赋值时，数据类型是否兼容
            - break语句是否出现在循环或switch-case语句中
            - 函数调用时，实参和形参的列表是否一一对应
            - ··· ···

    - 代码生成

        将抽象语法树转成汇编代码。

1. 汇编程序设计

    汇编程序的设计和编译程序的设计非常相似。它的任务是将汇编程序变为目标机器二进制代码。汇编代码的正确性可以由编译器保证。

    - 词法分析

        汇编语言有自己的词法记号，和编译程序一样，汇编程序也会有自己的有限自动机用于识别这些词法记号。

    - 语法分析

        在汇编程序设计中也有语法树。因为汇编器要输出可重定位目标文件，因此在语法分析时要收集目标文件的相关信息。此外，因为汇编语言允许符号的后置定义，所以需要对源文件进行两遍扫描。

            - mov指令
                - mov
                - 操作数
                    - eax
                - ,
                - 操作数
                    - [
                    - 地址
                        - ebp
                        - -
                        - 8
                    - ]

            mov eax, [ebp-8]的汇编指令抽象语法子树

    - 表信息生成
    - 指令生成

1. 链接程序设计

    链接这种操作使分离编译变得可能，可以将一个大型程序切分成很多子程序，分别编译。

    在汇编结束之后会产生分散独立的目标文件，链接程序的目的就是将这些分散的目标文件连成可执行文件。链接器在更多的时候是在做虚拟内存地址分配这件事。链接器和操作系统之间有着密切的关系。

    - 地址空间分配

        为程序段（计算机操作系统）分配基地址。

    - 符号解析

        为程序段内的符号分配地址。

    - 重定位

        重定位从本质上说是地址修正。目标文件在被链接之前是不知道自己符号的虚拟地址的，汇编器在生成目标文件的时候就会记录下需要重定位的位置、重定位的符号、重定位的类型（**重定位条目**），链接器再根据汇编器记录下的信息修改目标文件中的虚拟地址。重定位是链接器的最终要的部件，地址空间分配和符号解析都是在为重定位作铺垫。

## x86和ARM架构处理器

- x86俗称Intel处理器，ARM是进阶精简指令集机器（AdvancedRISCMachine）

- x86处理器通常用在PC中，性能强大、易于扩展、功耗大。

- ARM处理器通常用在移动设备、嵌入式系统中，大多执行单一固定的任务，性能较弱，但是功耗小。
